const { spawnSync } = require('child_process');
const path = require('path');
const fs = require('fs-extra');
const Promise = require('bluebird');
var JSZip = require('jszip');

function runCommand(cmd,args,options) {
  const ps = spawnSync(cmd, args,options);
  if (ps.error) {
    console.log(ps.error.code)
    throw new Error(ps.error);
  } else if (ps.status !== 0) {
    throw new Error(ps.stderr);
  }
  return ps;
}

function cleanBuild(){
  this.build_path = path.join(this.servicePath,'.serverless','build','ruby_layer')
  if (fs.pathExistsSync(this.build_path)){
    fs.rmdirSync(this.build_path,  { recursive: true }) 
  }
}

function bundleInstall(){
  this.serverless.cli.log(this.build_path)
  const gem_path = path.join(this.build_path,'Gemfile')
  fs.copySync(path.join(this.servicePath,'Gemfile'), gem_path )
  const bundle_args = ['bundle', 'install', '--path=.','--without', 'test', 'development']
  const options={cwd : this.build_path, encoding : 'utf8'}
  ps = runCommand("bundle",['-v'])
  if (ps.error && ps.error.code === 'ENOENT') {
     throw new Error('bundle command not found in local');
  }
  this.serverless.cli.log(bundle_args.slice(1,bundle_args.length))
  ps=runCommand(bundle_args[0],bundle_args.slice(1,bundle_args.length),options)
  this.serverless.cli.log(ps.stdout)
}

function zipDir(folder_path,targetPath,zipOptions){  
  zip = new JSZip()
  return addDirtoZip(zip, folder_path)
          .then(() => {
            return new Promise(resolve =>
                        zip.generateNodeStream(zipOptions)
                           .pipe(fs.createWriteStream(targetPath))
                           .on('finish', resolve))
                           .then(() => null)});
}

function addDirtoZip(zip, dir_path){
  const dir_path_norm = path.normalize(dir_path)
  return fs.readdirAsync(dir_path_norm)
           .map(file_name => {
              return addFiletoZip(zip, dir_path_norm, file_name)
            });
}

function addFiletoZip(zip, dir_path, file_name){
  const filePath = path.join(dir_path, file_name)
  return fs.statAsync(filePath)
          .then(stat => {
            if (stat.isDirectory()){
                return addDirtoZip(zip.folder(file_name), filePath);
            } else {
                const file_option = { date: stat.mtime, unixPermissions: stat.mode };
                return fs.readFileAsync(filePath)
                  .then(data => zip.file(file_name, data, file_option));
              }
          });
}

function zipBundleFolder() {
  this.gem_folder= fs.readdirSync(path.join(this.build_path,'ruby'))[0]
  fs.rmdirSync(path.join(this.build_path,'ruby',this.gem_folder,'cache'),{ recursive: true })
  const platform = process.platform == 'win32' ? 'DOS' : 'UNIX'
  return zipDir(path.join(this.build_path,'ruby'),
                path.join(this.build_path, 'gemLayer.zip'), 
                { platform: platform, compression: 'DEFLATE',
                compressionOptions: { level: 9 }});
}

function configureLayer() {
  if (!this.serverless.service.layers) {
    this.serverless.service.layers = {};
  }

  this.serverless.service.layers['gemLayer'] = Object.assign(
    {
      artifact: path.join(this.build_path, 'gemLayer.zip'),
      name: `${
        this.serverless.service.service
      }-${this.serverless.providers.aws.getStage()}-ruby-bundle`,
      description:
        'Ruby gem generated by serverless-ruby-bundler',
      compatibleRuntimes: [this.serverless.service.provider.runtime]
    },
    this.options.layer
  );

  Object.keys(this.serverless.service.functions).forEach(funcName => {
    const function_ = this.serverless.service.getFunction(funcName)
    function_.environment={}
    function_.environment["GEM_PATH"]="/opt/"+this.gem_folder
    function_.layers = [{"Ref":"GemLayerLambdaLayer"}]
  })
  return Promise.resolve();
}

function bundleGems()  {
  return Promise.bind(this)
          .then(cleanBuild)
          .then(bundleInstall)
          .then(zipBundleFolder)
          .then(configureLayer)
} 

module.exports = { bundleGems};
